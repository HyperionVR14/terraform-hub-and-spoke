name: Deploy Web Content (HTML)

on:
  push:
    branches: [ main ]
    paths:
      - 'my-html-app/**'
  workflow_dispatch: {}

concurrency:
  group: webapp-content
  cancel-in-progress: true

permissions:
  contents: read

env:
  PRIVATE_MODE: 'false'   #it is false for the deploy to be easier

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4

      - name: Create build marker
        run: |
          mkdir -p my-html-app
          {
            echo "repo=$GITHUB_REPOSITORY"
            echo "commit=$GITHUB_SHA"
            echo "run_id=$GITHUB_RUN_ID"
            echo "date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
          } > my-html-app/_buildinfo.txt

      - name: Deploy to Azure WebApp
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ secrets.AZURE_WEBAPP_NAME }}
          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
          package: my-html-app

      # Kudu creds (for VFS checks)
      - name: Extract Kudu credentials
        id: kudu
        if: env.PRIVATE_MODE != 'true'
        env:
          PUBLISH_PROFILE: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
        shell: bash
        run: |
          python3 - <<'PY'
          import os, xml.etree.ElementTree as ET
          xml = os.environ['PUBLISH_PROFILE']
          root = ET.fromstring(xml)
          user = pwd = scm = None
          for p in root.findall(".//publishProfile[@publishMethod='MSDeploy']"):
              user = p.attrib.get('userName')
              pwd  = p.attrib.get('userPWD')
              url  = p.attrib.get('publishUrl')  # <app>.scm.azurewebsites.net:443
              scm  = f"https://{url.split(':')[0]}"
              break
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"user={user}\n")
              f.write(f"pass={pwd}\n")
              f.write(f"scm={scm}\n")
          PY

      # Smoke 1: waiting for 200 on first page
      - name: Smoke - Wait for 200 OK
        if: env.PRIVATE_MODE != 'true'
        shell: bash
        run: |
          URL="https://${{ secrets.AZURE_WEBAPP_NAME }}.azurewebsites.net/"
          for i in {1..20}; do
            code=$(curl -k -sS -o /dev/null -w "%{http_code}" "$URL" || true)
            echo "Attempt $i -> HTTP $code"
            [ "$code" = "200" ] && exit 0
            sleep 5
          done
          echo "Site did not return 200 within the timeout."
          exit 1

      # Smoke 2: Checking content of the page for "Practical Exam.."
      - name: Smoke - Check homepage content
        if: env.PRIVATE_MODE != 'true'
        shell: bash
        run: |
          URL="https://${{ secrets.AZURE_WEBAPP_NAME }}.azurewebsites.net/"
          body=$(curl -sS "$URL")
          echo "$body" | grep -qi "Practical Exam Task" || { echo "Homepage marker not found"; exit 0; }
          echo "Homepage content OK."

      - name: Smoke - Kudu VFS index.html (GET)
        if: env.PRIVATE_MODE != 'true'
        env:
          KUDU_USER: ${{ steps.kudu.outputs.user }}
          KUDU_PASS: ${{ steps.kudu.outputs.pass }}
          KUDU_SCM:  ${{ steps.kudu.outputs.scm }}
        shell: bash
        run: |
          # Generating Basic header without new line
          AUTH=$(printf '%s' "${KUDU_USER}:${KUDU_PASS}" | base64 -w0 2>/dev/null || python3 -c "import sys,base64;print(base64.b64encode(sys.stdin.buffer.read()).decode())")
          URL="${KUDU_SCM}/api/vfs/site/wwwroot/index.html"
      
          # Getting the file with GET, forcing http/1.1 for stability
          code=$(curl --http1.1 -sS -L -D /tmp/headers.txt -o /tmp/index.html \
                 -w "%{http_code}" -H "Authorization: Basic ${AUTH}" "$URL" || true)
      
          echo "HTTP $code"; echo "---- headers ----"; cat /tmp/headers.txt
          [ "$code" = "200" ] || { echo "index.html not accessible via Kudu VFS"; exit 1; }
          echo "Kudu VFS index.html OK."

      - name: Smoke - Kudu VFS buildinfo (200 + content + SHA)
        if: env.PRIVATE_MODE != 'true'
        env:
          KUDU_USER: ${{ steps.kudu.outputs.user }}
          KUDU_PASS: ${{ steps.kudu.outputs.pass }}
          KUDU_SCM:  ${{ steps.kudu.outputs.scm }}
        shell: bash
        run: |
          # Generating Authorization without \n by default, otherwise challenges :D)
          AUTH=$(printf '%s' "${KUDU_USER}:${KUDU_PASS}" | base64 -w0 2>/dev/null || python3 - <<'PY'
          import os, base64; print(base64.b64encode(f"{os.environ['KUDU_USER']}:{os.environ['KUDU_PASS']}".encode()).decode(), end="")
          PY
          )
              URL="${KUDU_SCM}/api/vfs/site/wwwroot/_buildinfo.txt"
      
          # Getting the file with GET, and checking code
          code=$(curl --http1.1 -sS -L -D /tmp/headers.txt -o /tmp/_buildinfo.txt \
                 -w "%{http_code}" -H "Authorization: Basic ${AUTH}" "$URL" || true)
      
          echo "HTTP $code"
          echo "---- headers ----"
          cat /tmp/headers.txt || true
          echo "---- _buildinfo.txt ----"
          head -n 20 /tmp/_buildinfo.txt || true
      
          [ "$code" = "200" ] || { echo "Kudu VFS returned $code (not 200)"; exit 1; }
      
          if grep -q "commit=${GITHUB_SHA}" /tmp/_buildinfo.txt; then
            echo "Exact SHA match OK."
          else
            SHORT=$(echo "$GITHUB_SHA" | cut -c1-7)
            grep -q "commit=${SHORT}" /tmp/_buildinfo.txt || { echo "Build SHA not found in _buildinfo.txt"; exit 1; }
            echo "Short SHA match OK."
          fi
      
          echo "Kudu VFS buildinfo OK."